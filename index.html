<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAX30011 Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- プラグインは一時的に無効化 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        *:focus {
            outline: none !important;
        }

        label, input, button, select, textarea {
            outline: none !important;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #ffffff;
            color: #333;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .app-container {
            display: flex;
            height: calc(100vh - 64px);
            overflow: hidden;
        }

        .left-panel {
            width: 320px;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 20px;
        }

        .right-panel {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #ffffff;
        }

        .section {
            margin-bottom: 24px;
            background: white;
            padding: 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border: none !important;
        }

        .section.file-section {
            padding: 0;
            background: transparent;
            box-shadow: none;
            border-radius: 0;
        }

        .section * {
            border: none !important;
        }

        .section *:hover {
            border: none !important;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .file-upload {
            display: block;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s;
            background-color: #fafbfc;
        }

        .file-upload:hover {
            border-color: #667eea;
            background-color: #f0f3ff;
        }

        .file-upload.drag-over {
            border-color: #667eea;
            background-color: #e7f0ff;
        }

        .file-upload input {
            display: none;
        }

        .file-info {
            margin-top: 12px;
            padding: 12px;
            background: #e7f5ff;
            border-radius: 6px;
            font-size: 13px;
            color: #1864ab;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #495057;
            margin-bottom: 6px;
        }

        .input-field {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 6px;
            transition: background 0.2s;
        }

        .checkbox-group:hover {
            background: #f8f9fa;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-group label {
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            flex: 1;
        }

        .filter-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-left: 26px;
            margin-top: 8px;
        }

        .select-field {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 13px;
            background: white;
            cursor: pointer;
        }

        .graph-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .graph-title {
            font-size: 16px;
            font-weight: 600;
            color: #212529;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .graph-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .control-item input {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 13px;
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 16px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .time-display {
            font-size: 13px;
            font-weight: 500;
            color: #495057;
            min-width: 100px;
            text-align: right;
        }

        .band-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .band-card {
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid;
        }

        .band-card.delta {
            background: #e7f5ff;
            border-color: #1f77b4;
        }

        .band-card.theta {
            background: #ebfbee;
            border-color: #2ca02c;
        }

        .band-card.alpha {
            background: #fff9db;
            border-color: #bcbd22;
        }

        .band-card.beta {
            background: #fff4e6;
            border-color: #ff7f0e;
        }

        .band-card.gamma {
            background: #ffe3e3;
            border-color: #d62728;
        }

        .band-name {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .band-value {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .band-detail {
            font-size: 11px;
            color: #6c757d;
        }

        .stat-card {
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 11px;
            color: #6c757d;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 700;
            color: #212529;
        }

        .export-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .radio-group {
            display: flex;
            gap: 16px;
            margin-top: 8px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .radio-item input {
            cursor: pointer;
        }

        .radio-item label {
            font-size: 13px;
            cursor: pointer;
        }

        canvas {
            max-height: 300px;
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            .left-panel {
                width: 100%;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="header">MAX30011 Analyzer</div>
    <div class="app-container">
        <div class="left-panel" id="leftPanel"></div>
        <div class="right-panel" id="rightPanel"></div>
    </div>

    <script>
        // ==================== グローバル変数 ====================
        let rawData = [];
        let filteredData = [];
        let currentTime = 0;
        let isPlaying = false;
        let playbackInterval = null;
        let waveformChart = null;
        let fftChart = null;
        let bandChart = null;
        
        // 新機能用
        let eventMarkers = []; // イベントマーカー
        let isECG = false; // ECG自動判定
        let rPeaks = []; // R波ピーク位置
        let artifacts = []; // アーチファクト位置

        // 設定
        let config = {
            samplingRate: 128,
            playbackSpeed: 1,
            displayWindow: 5,  // 5秒に変更
            hpfEnabled: true,
            hpfFreq: 3.0,
            hpfOrder: 2,
            lpfEnabled: true,
            lpfFreq: 40.0,
            lpfOrder: 2,
            notch50Enabled: true,
            notch60Enabled: true,
            yMin: -200,
            yMax: 200,
            autoScale: true,
            
            // FFTグラフのスケール設定
            fftYMin: 0,
            fftYMax: 100,
            fftAutoScale: true,
            fftXMin: 0,
            fftXMax: 50,
            fftXAutoScale: true,
            
            // 帯域グラフのスケール設定
            bandYMin: 0,
            bandYMax: 500,
            bandAutoScale: true,
            
            fftMinFreq: 3,
            fftMaxFreq: 40,
            fftYScale: 'power',
            showRaw: false, // Raw波形表示切替
            enableECG: false, // 心電検出（デフォルトOFF）
            ecgThreshold: 60, // R波検出の閾値（%）
            detectArtifacts: true, // アーチファクト検出
            artifactThreshold: 5, // アーチファクト閾値（標準偏差の倍数）
        };

        // プリセット定義
        const presets = {
            'Default': {
                hpfFreq: 3.0, hpfOrder: 2, lpfFreq: 40.0, lpfOrder: 2,
                notch50Enabled: true, notch60Enabled: true, fftMinFreq: 3, fftMaxFreq: 40
            },
            'Sleep': {
                hpfFreq: 0.5, hpfOrder: 2, lpfFreq: 30.0, lpfOrder: 2,
                notch50Enabled: true, notch60Enabled: true, fftMinFreq: 0.5, fftMaxFreq: 30
            },
            'Active': {
                hpfFreq: 1.0, hpfOrder: 2, lpfFreq: 50.0, lpfOrder: 2,
                notch50Enabled: true, notch60Enabled: true, fftMinFreq: 1, fftMaxFreq: 50
            },
            'Meditation': {
                hpfFreq: 0.5, hpfOrder: 2, lpfFreq: 13.0, lpfOrder: 2,
                notch50Enabled: true, notch60Enabled: true, fftMinFreq: 0.5, fftMaxFreq: 13
            }
        };

        // ==================== IIRフィルター実装 ====================
        class IirFilter {
            constructor(filterFreq, filterOrder, sampleFreq) {
                this.filterFreq = filterFreq;
                this.filterOrder = filterOrder;
                this.sampleFreq = sampleFreq;
                this.b = [0, 0, 0];
                this.a = [0, 0, 0];
                this.w = [0, 0, 0];
                this.calcCoef();
            }

            filter(x) {
                const y = new Array(x.length);
                for (let i = 0; i < x.length; i++) {
                    y[i] = this.filterEach(x[i]);
                }
                return y;
            }

            filterEach(x) {
                if (this.filterOrder === 1) {
                    return this.filter1st(x);
                } else {
                    return this.filter2nd(x);
                }
            }

            filter1st(x) {
                const y = this.b[0] * x + this.w[0];
                this.w[0] = this.b[1] * x - this.a[1] * y + this.w[1];
                return y;
            }

            filter2nd(x) {
                const y = this.b[0] * x + this.w[0];
                this.w[0] = this.b[1] * x - this.a[1] * y + this.w[1];
                this.w[1] = this.b[2] * x - this.a[2] * y;
                return y;
            }

            resetFilterBuf() {
                this.w = [0, 0, 0];
            }
        }

        class Hpf extends IirFilter {
            calcCoef() {
                const r = Math.tan(Math.PI * this.filterFreq / this.sampleFreq);
                if (this.filterOrder === 1) {
                    this.b[0] = 1.0 / (r + 1.0);
                    this.b[1] = -this.b[0];
                    this.b[2] = 0.0;
                    this.a[0] = 1.0;
                    this.a[1] = (r - 1.0) / (r + 1.0);
                    this.a[2] = 0.0;
                } else {
                    const d = r * r + Math.sqrt(2.0) * r + 1.0;
                    this.b[0] = 1.0 / d;
                    this.b[1] = -2.0 * this.b[0];
                    this.b[2] = this.b[0];
                    this.a[0] = 1.0;
                    this.a[1] = 2.0 * (r * r - 1.0) / d;
                    this.a[2] = 1.0 - 2.0 * Math.sqrt(2.0) * r / d;
                }
            }
        }

        class Lpf extends IirFilter {
            calcCoef() {
                const r = Math.tan(Math.PI * this.filterFreq / this.sampleFreq);
                if (this.filterOrder === 1) {
                    this.b[0] = r / (r + 1.0);
                    this.b[1] = this.b[0];
                    this.b[2] = 0.0;
                    this.a[0] = 1.0;
                    this.a[1] = (r - 1.0) / (r + 1.0);
                    this.a[2] = 0.0;
                } else {
                    const d = r * r + Math.sqrt(2.0) * r + 1.0;
                    this.b[0] = r * r / d;
                    this.b[1] = 2.0 * this.b[0];
                    this.b[2] = this.b[0];
                    this.a[0] = 1.0;
                    this.a[1] = 2.0 * (r * r - 1.0) / d;
                    this.a[2] = 1.0 - 2.0 * Math.sqrt(2.0) * r / d;
                }
            }
        }

        class Bef extends IirFilter {
            constructor(filterFreq, sampleFreq, qValue = 2.0) {
                super(filterFreq, 2, sampleFreq);
                this.qValue = qValue;
                this.calcCoef();
            }

            calcCoef() {
                const a = Math.cos(2.0 * Math.PI * this.filterFreq / this.sampleFreq);
                const b = 1.0 / (1.0 + Math.tan(Math.PI * this.filterFreq / this.qValue / this.sampleFreq));
                this.b[0] = b;
                this.b[1] = -2.0 * b * a;
                this.b[2] = b;
                this.a[0] = 1.0;
                this.a[1] = -2.0 * b * a;
                this.a[2] = 2.0 * b - 1;
            }
        }

        class FilterSet {
            constructor(hpfFreq, hpfOrder, lpfFreq, lpfOrder, samplingFreq) {
                this.hpf = new Hpf(hpfFreq, hpfOrder, samplingFreq);
                this.lpf = new Lpf(lpfFreq, lpfOrder, samplingFreq);
                this.bef50 = new Bef(50.0, samplingFreq);
                this.bef60 = new Bef(60.0, samplingFreq);
            }

            filter(x, hpfEnabled, lpfEnabled, bef50Enabled, bef60Enabled) {
                let y = [...x];
                if (hpfEnabled) y = this.hpf.filter(y);
                if (lpfEnabled) y = this.lpf.filter(y);
                if (bef50Enabled) y = this.bef50.filter(y);
                if (bef60Enabled) y = this.bef60.filter(y);
                return y;
            }
        }

        // ==================== FFT関連 ====================
        function hammingWindow(n) {
            const window = new Array(n);
            for (let i = 0; i < n; i++) {
                window[i] = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (n - 1));
            }
            return window;
        }

        function fft(input) {
            const n = input.length;
            if (n <= 1) return input;
            if (n % 2 !== 0) throw new Error('FFT size must be power of 2');

            const even = fft(input.filter((_, i) => i % 2 === 0));
            const odd = fft(input.filter((_, i) => i % 2 === 1));

            const result = new Array(n);
            for (let k = 0; k < n / 2; k++) {
                const angle = -2 * Math.PI * k / n;
                const t = { 
                    re: Math.cos(angle) * odd[k].re - Math.sin(angle) * odd[k].im,
                    im: Math.cos(angle) * odd[k].im + Math.sin(angle) * odd[k].re 
                };
                result[k] = { re: even[k].re + t.re, im: even[k].im + t.im };
                result[k + n / 2] = { re: even[k].re - t.re, im: even[k].im - t.im };
            }
            return result;
        }

        // ==================== Welchのパワースペクトル密度（PSD）推定 ====================
        function welchPowerSpectrum(data, samplingRate, segmentSize = 512, overlap = 0.5) {
            // Welch法によるパワースペクトル密度（PSD）の推定
            // 戻り値: { freqs: 周波数配列 (Hz), power: PSD配列 (μV²/Hz) }
            const step = Math.floor(segmentSize * (1 - overlap));
            const window = hammingWindow(segmentSize);
            let powerSum = new Array(segmentSize / 2).fill(0);
            let count = 0;

            for (let i = 0; i + segmentSize <= data.length; i += step) {
                const segment = data.slice(i, i + segmentSize);
                const windowed = segment.map((val, idx) => val * window[idx]);
                
                const paddedSize = Math.pow(2, Math.ceil(Math.log2(segmentSize)));
                const padded = new Array(paddedSize).fill(0).map((_, idx) => 
                    idx < segmentSize ? { re: windowed[idx], im: 0 } : { re: 0, im: 0 }
                );

                const fftResult = fft(padded);
                
                for (let j = 0; j < segmentSize / 2; j++) {
                    const magnitude = Math.sqrt(fftResult[j].re ** 2 + fftResult[j].im ** 2);
                    powerSum[j] += magnitude ** 2 / segmentSize;
                }
                count++;
            }

            // パワースペクトル密度（PSD）を計算：周波数分解能で割る
            const frequencyResolution = samplingRate / segmentSize; // Δf = fs / N
            const psd = powerSum.map(p => (p / count) / frequencyResolution); // μV²/Hz
            const freqs = psd.map((_, i) => i * frequencyResolution);
            
            return { freqs, power: psd };
        }

        function calculateBandPower(freqs, psd, minFreq, maxFreq) {
            // PSD (μV²/Hz) を周波数帯域で積分して帯域パワー (μV²) を計算
            // ∫ PSD(f) df ≈ Σ PSD(f) × Δf
            let bandPower = 0;
            let peakPower = 0;
            let peakFreq = minFreq;
            
            // 周波数分解能を計算
            const df = freqs.length > 1 ? freqs[1] - freqs[0] : 1;

            for (let i = 0; i < freqs.length; i++) {
                if (freqs[i] >= minFreq && freqs[i] <= maxFreq) {
                    // PSD × Δf で積分（単位: μV²）
                    bandPower += psd[i] * df;
                    if (psd[i] > peakPower) {
                        peakPower = psd[i];
                        peakFreq = freqs[i];
                    }
                }
            }
            return { power: bandPower, peakFreq };
        }

        // ==================== スペクトログラム ====================
        function calculateSpectrogram(data, windowSize = 256, overlap = 0.9) {
            const step = Math.floor(windowSize * (1 - overlap));
            const window = hammingWindow(windowSize);
            const spectrogram = [];
            const times = [];
            let freqs = null;
            
            for (let i = 0; i + windowSize <= data.length; i += step) {
                const segment = data.slice(i, i + windowSize);
                const windowed = segment.map((val, idx) => val * window[idx]);
                
                const paddedSize = Math.pow(2, Math.ceil(Math.log2(windowSize)));
                const padded = new Array(paddedSize).fill(0).map((_, idx) => 
                    idx < windowSize ? { re: windowed[idx], im: 0 } : { re: 0, im: 0 }
                );
                
                const fftResult = fft(padded);
                const power = fftResult.slice(0, windowSize / 2).map(c => 
                    Math.log10(c.re ** 2 + c.im ** 2 + 1e-10) * 10 // dB変換
                );
                
                spectrogram.push(power);
                times.push(i / config.samplingRate);
                
                if (!freqs) {
                    freqs = power.map((_, idx) => idx * config.samplingRate / windowSize);
                }
            }
            
            return { spectrogram, times, freqs };
        }

        function updateHeatmap() {
            const canvas = document.getElementById('heatmapCanvas');
            if (!canvas) return;
            
            const startTime = currentTime;
            const endTime = currentTime + config.displayWindow;
            const startIdx = Math.floor(startTime * config.samplingRate);
            const endIdx = Math.floor(endTime * config.samplingRate);
            const spectrogramData = filteredData.slice(startIdx, Math.min(endIdx, filteredData.length));
            
            if (spectrogramData.length < 512) {
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('データが不足しています（512サンプル以上必要）', canvas.width / 2, canvas.height / 2);
                return;
            }

            const values = spectrogramData.map(d => d.filtered);
            const { spectrogram, times, freqs } = calculateSpectrogram(values, 256, 0.9);
            
            // Canvas設定
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            const ctx = canvas.getContext('2d');
            
            // マージン設定
            const margin = { top: 10, right: 60, bottom: 30, left: 50 };
            const plotWidth = canvas.width - margin.left - margin.right;
            const plotHeight = canvas.height - margin.top - margin.bottom;
            
            // 背景を白に
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 周波数範囲をフィルタ
            const minFreqIdx = freqs.findIndex(f => f >= config.fftMinFreq);
            const maxFreqIdx = freqs.findIndex(f => f > config.fftMaxFreq);
            const validMaxFreqIdx = maxFreqIdx > 0 ? maxFreqIdx - 1 : freqs.length - 1;
            
            // データ範囲を計算
            let minVal = Infinity;
            let maxVal = -Infinity;
            spectrogram.forEach(spectrum => {
                for (let i = minFreqIdx; i <= validMaxFreqIdx; i++) {
                    minVal = Math.min(minVal, spectrum[i]);
                    maxVal = Math.max(maxVal, spectrum[i]);
                }
            });
            
            // ヒートマップ描画（バイリニア補間で滑らかに）
            const imgData = ctx.createImageData(plotWidth, plotHeight);
            const data = imgData.data;
            
            for (let py = 0; py < plotHeight; py++) {
                // Y座標から周波数を計算（反転：上が高周波）
                const freq = config.fftMaxFreq - (py / plotHeight) * (config.fftMaxFreq - config.fftMinFreq);
                
                for (let px = 0; px < plotWidth; px++) {
                    // X座標から時間インデックスを計算
                    const timeRatio = px / plotWidth;
                    const timeIdx = timeRatio * (spectrogram.length - 1);
                    
                    // バイリニア補間
                    const t0 = Math.floor(timeIdx);
                    const t1 = Math.min(t0 + 1, spectrogram.length - 1);
                    const tFrac = timeIdx - t0;
                    
                    // 周波数インデックスを計算
                    const freqRatio = (config.fftMaxFreq - freq) / (config.fftMaxFreq - config.fftMinFreq);
                    const freqIdx = minFreqIdx + freqRatio * (validMaxFreqIdx - minFreqIdx);
                    const f0 = Math.floor(freqIdx);
                    const f1 = Math.min(f0 + 1, validMaxFreqIdx);
                    const fFrac = freqIdx - f0;
                    
                    if (t0 >= 0 && t1 < spectrogram.length && f0 >= minFreqIdx && f1 <= validMaxFreqIdx) {
                        // 4点のパワー値を取得
                        const v00 = spectrogram[t0][f0];
                        const v01 = spectrogram[t0][f1];
                        const v10 = spectrogram[t1][f0];
                        const v11 = spectrogram[t1][f1];
                        
                        // バイリニア補間
                        const v0 = v00 * (1 - fFrac) + v01 * fFrac;
                        const v1 = v10 * (1 - fFrac) + v11 * fFrac;
                        const value = v0 * (1 - tFrac) + v1 * tFrac;
                        
                        const normalized = (value - minVal) / (maxVal - minVal);
                        const color = valueToColor(normalized);
                        
                        const idx = (py * plotWidth + px) * 4;
                        data[idx] = color.r;
                        data[idx + 1] = color.g;
                        data[idx + 2] = color.b;
                        data[idx + 3] = 255;
                    } else {
                        const idx = (py * plotWidth + px) * 4;
                        data[idx] = 240;
                        data[idx + 1] = 240;
                        data[idx + 2] = 240;
                        data[idx + 3] = 255;
                    }
                }
            }
            
            ctx.putImageData(imgData, margin.left, margin.top);
            
            // 軸とラベルを描画
            drawHeatmapAxes(ctx, margin, plotWidth, plotHeight, startTime, endTime, minVal, maxVal);
            
            // カラーバーを描画
            drawColorbar(minVal, maxVal);
        }

        function valueToColor(normalized) {
            // 青 → シアン → 緑 → 黄 → 赤のグラデーション
            normalized = Math.max(0, Math.min(1, normalized));
            
            let r, g, b;
            
            if (normalized < 0.25) {
                // 青 → シアン
                const t = normalized / 0.25;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (normalized < 0.5) {
                // シアン → 緑
                const t = (normalized - 0.25) / 0.25;
                r = 0;
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else if (normalized < 0.75) {
                // 緑 → 黄
                const t = (normalized - 0.5) / 0.25;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
            } else {
                // 黄 → 赤
                const t = (normalized - 0.75) / 0.25;
                r = 255;
                g = Math.floor((1 - t) * 255);
                b = 0;
            }
            
            return { r, g, b };
        }

        function drawHeatmapAxes(ctx, margin, plotWidth, plotHeight, startTime, endTime, minVal, maxVal) {
            ctx.strokeStyle = '#333';
            ctx.fillStyle = '#333';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            // 左軸（周波数）
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + plotHeight);
            ctx.stroke();
            
            // 下軸（時間）
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top + plotHeight);
            ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
            ctx.stroke();
            
            // Y軸ラベル（周波数）
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            const freqTicks = 5;
            for (let i = 0; i <= freqTicks; i++) {
                const freq = config.fftMinFreq + (i / freqTicks) * (config.fftMaxFreq - config.fftMinFreq);
                const y = margin.top + plotHeight - (i / freqTicks) * plotHeight;
                ctx.fillText(freq.toFixed(0) + ' Hz', margin.left - 5, y);
                
                // 目盛り
                ctx.beginPath();
                ctx.moveTo(margin.left - 3, y);
                ctx.lineTo(margin.left, y);
                ctx.stroke();
            }
            
            // X軸ラベル（時間）
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const timeTicks = 5;
            for (let i = 0; i <= timeTicks; i++) {
                const time = startTime + (i / timeTicks) * (endTime - startTime);
                const x = margin.left + (i / timeTicks) * plotWidth;
                ctx.fillText(time.toFixed(1) + ' s', x, margin.top + plotHeight + 5);
                
                // 目盛り
                ctx.beginPath();
                ctx.moveTo(x, margin.top + plotHeight);
                ctx.lineTo(x, margin.top + plotHeight + 3);
                ctx.stroke();
            }
            
            // 軸タイトル
            ctx.save();
            ctx.translate(15, margin.top + plotHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '12px Arial';
            ctx.fillText('周波数 (Hz)', 0, 0);
            ctx.restore();
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.font = '12px Arial';
            ctx.fillText('時間 (秒)', margin.left + plotWidth / 2, margin.top + plotHeight + 20);
        }

        function drawColorbar(minVal, maxVal) {
            const colorbar = document.getElementById('heatmapColorbar');
            if (!colorbar) return;
            
            // グラデーションを作成
            let html = '<div style="height: 100%; display: flex; flex-direction: column; border-radius: 2px; overflow: hidden;">';
            for (let i = 0; i <= 100; i++) {
                const normalized = 1 - (i / 100);
                const color = valueToColor(normalized);
                html += `<div style="flex: 1; background: rgb(${color.r}, ${color.g}, ${color.b});"></div>`;
            }
            html += '</div>';
            
            // ラベル追加（右側に配置）
            html += `<div style="position: absolute; left: 30px; top: -2px; font-size: 10px; color: #333; font-weight: 500; white-space: nowrap;">${maxVal.toFixed(1)}</div>`;
            html += `<div style="position: absolute; left: 30px; bottom: -2px; font-size: 10px; color: #333; font-weight: 500; white-space: nowrap;">${minVal.toFixed(1)}</div>`;
            html += `<div style="position: absolute; left: 30px; top: 50%; transform: translateY(-50%); font-size: 9px; color: #666; white-space: nowrap;">dB</div>`;
            
            colorbar.innerHTML = html;
        }

        // ==================== アーチファクト検出 ====================
        function detectArtifacts(data, threshold = 5) {
            const values = data.map(d => d.filtered);
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const std = Math.sqrt(
                values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length
            );
            
            const artifacts = [];
            const upperLimit = mean + threshold * std;
            const lowerLimit = mean - threshold * std;
            
            for (let i = 0; i < data.length; i++) {
                if (values[i] > upperLimit || values[i] < lowerLimit) {
                    artifacts.push({
                        index: i,
                        time: data[i].time,
                        value: values[i],
                        type: values[i] > upperLimit ? 'high' : 'low'
                    });
                }
            }
            
            return artifacts;
        }

        // ==================== ECG検出とR波検出 ====================
        function detectECG(data) {
            // 簡易的なECG判定：ピークの規則性とQRS複合体の特徴を検出
            if (data.length < config.samplingRate * 5) return false; // 最低5秒必要
            
            const values = data.map(d => d.filtered);
            const peaks = findPeaks(values, config.samplingRate);
            
            if (peaks.length < 3) return false;
            
            // ピーク間隔の変動係数を計算（心拍の規則性を判定）
            const intervals = [];
            for (let i = 1; i < peaks.length; i++) {
                intervals.push(peaks[i] - peaks[i-1]);
            }
            
            const meanInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const stdInterval = Math.sqrt(
                intervals.reduce((a, b) => a + Math.pow(b - meanInterval, 2), 0) / intervals.length
            );
            const cv = stdInterval / meanInterval;
            
            // 心拍数が妥当な範囲（40-200 BPM）で、変動係数が比較的小さい場合にECGと判定
            const bpm = 60 * config.samplingRate / meanInterval;
            const isECG = bpm >= 40 && bpm <= 200 && cv < 0.5;
            
            console.log('ECG Detection:', { peaks: peaks.length, bpm: bpm.toFixed(1), cv: cv.toFixed(3), isECG });
            
            return isECG;
        }

        function findPeaks(values, samplingRate, thresholdPercent = 60) {
            // 改善されたR波検出アルゴリズム（過剰検出を防ぐ）
            const peaks = [];
            
            // データの範囲を計算
            const maxVal = Math.max(...values);
            const minVal = Math.min(...values);
            const range = maxVal - minVal;
            
            // 閾値をパーセンテージで設定（ユーザー調整可能）
            const threshold = minVal + range * (thresholdPercent / 100);
            
            // 最小間隔を350msに設定（約170BPM対応）
            const minDistance = Math.floor(samplingRate * 0.35);
            
            console.log('Peak Detection:', { 
                maxVal: maxVal.toFixed(2), 
                minVal: minVal.toFixed(2), 
                range: range.toFixed(2),
                thresholdPercent: thresholdPercent + '%',
                threshold: threshold.toFixed(2),
                minDistance,
                samplingRate
            });
            
            // より大きなウィンドウサイズ（前後5サンプル）
            const windowSize = 5;
            
            for (let i = windowSize; i < values.length - windowSize; i++) {
                // 閾値を超え、かつ局所的な最大値
                if (values[i] > threshold) {
                    let isLocalMax = true;
                    
                    // ウィンドウ内で厳格に最大かチェック
                    for (let j = -windowSize; j <= windowSize; j++) {
                        if (j !== 0 && values[i] <= values[i + j]) {
                            isLocalMax = false;
                            break;
                        }
                    }
                    
                    if (isLocalMax) {
                        // 前のピークから十分な距離があるか確認
                        if (peaks.length === 0 || i - peaks[peaks.length - 1] > minDistance) {
                            peaks.push(i);
                        } else if (values[i] > values[peaks[peaks.length - 1]]) {
                            // 近すぎる場合、より大きい方を採用
                            peaks[peaks.length - 1] = i;
                        }
                    }
                }
            }
            
            console.log('Peaks found:', peaks.length);
            if (peaks.length > 0) {
                // ピーク間隔の統計
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push((peaks[i] - peaks[i-1]) / samplingRate);
                }
                if (intervals.length > 0) {
                    const meanInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const bpm = 60 / meanInterval;
                    console.log('Average interval:', meanInterval.toFixed(3), 's, BPM:', bpm.toFixed(1));
                }
            }
            
            return peaks;
        }

        function calculateHeartRate(peaks, samplingRate) {
            if (peaks.length < 2) return null;
            
            const intervals = [];
            for (let i = 1; i < peaks.length; i++) {
                intervals.push((peaks[i] - peaks[i-1]) / samplingRate);
            }
            
            const meanInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
            const bpm = 60 / meanInterval;
            const hrv = Math.sqrt(
                intervals.reduce((a, b) => a + Math.pow(b - meanInterval, 2), 0) / intervals.length
            ) * 1000; // ms
            
            return {
                bpm: bpm.toFixed(1),
                hrv: hrv.toFixed(1),
                intervals: intervals
            };
        }

        // ==================== パフォーマンス最適化 ====================
        function downsampleData(data, maxPoints = 2000) {
            // データポイント数が多い場合、間引いて表示
            if (data.length <= maxPoints) {
                return data;
            }
            
            const downsampled = [];
            const step = data.length / maxPoints;
            
            for (let i = 0; i < data.length; i += step) {
                const index = Math.floor(i);
                downsampled.push(data[index]);
            }
            
            return downsampled;
        }

        // ==================== 統計情報計算 ====================
        function calculateStatistics(data) {
            if (data.length === 0) return null;
            
            const values = data.map(d => d.filtered);
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const std = Math.sqrt(variance);
            const max = Math.max(...values);
            const min = Math.min(...values);
            const peakToPeak = max - min;
            const rms = Math.sqrt(values.reduce((a, b) => a + b * b, 0) / values.length);
            
            return {
                mean: mean.toFixed(2),
                std: std.toFixed(2),
                max: max.toFixed(2),
                min: min.toFixed(2),
                peakToPeak: peakToPeak.toFixed(2),
                rms: rms.toFixed(2),
                samples: values.length
            };
        }

        // ==================== データ処理 ====================
        function parseMAX30011CSV(csvText) {
            const ADC_TO_MV = 1.19209E-05; // ADC値からmVへの変換係数
            const MV_TO_UV = 1000; // mVからμVへの変換（1000倍）
            const CONVERSION_FACTOR = ADC_TO_MV * MV_TO_UV; // 合計: 1.19209E-02
            
            const lines = csvText.split('\n');
            const data = [];
            let dataStarted = false;

            for (let line of lines) {
                if (line.includes('timestamp,sampleNum')) {
                    dataStarted = true;
                    continue;
                }
                if (dataStarted && line.trim()) {
                    const parts = line.split(',');
                    if (parts.length >= 4 && parts[3].trim() !== '') {
                        const timestamp = parseFloat(parts[0]);
                        const rawADC = parseFloat(parts[3]); // ADC生データ
                        const value = rawADC * CONVERSION_FACTOR; // μVに変換
                        if (!isNaN(timestamp) && !isNaN(value)) {
                            data.push({ timestamp, value, rawADC }); // ADC値も保存
                        }
                    }
                }
            }
            return data;
        }

        function applyFilters() {
            if (rawData.length === 0) return;

            const filterSet = new FilterSet(
                config.hpfFreq, config.hpfOrder,
                config.lpfFreq, config.lpfOrder,
                config.samplingRate
            );

            const values = rawData.map(d => d.value);
            const filtered = filterSet.filter(
                values,
                config.hpfEnabled,
                config.lpfEnabled,
                config.notch50Enabled,
                config.notch60Enabled
            );
            
            filteredData = rawData.map((d, i) => ({
                timestamp: d.timestamp,
                time: i / config.samplingRate,
                raw: d.value,
                filtered: filtered[i]
            }));

            if (config.autoScale) {
                const values = filteredData.map(d => d.filtered);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const margin = (max - min) * 0.1;
                config.yMin = Math.floor(min - margin);
                config.yMax = Math.ceil(max + margin);
            }

            // 心電検出
            if (config.enableECG) {
                isECG = true;
                const values = filteredData.map(d => d.filtered);
                rPeaks = findPeaks(values, config.samplingRate, config.ecgThreshold);
                console.log('ECG mode enabled: R-peaks found:', rPeaks.length);
            } else {
                isECG = false;
                rPeaks = [];
            }

            // アーチファクト検出
            if (config.detectArtifacts) {
                artifacts = detectArtifacts(filteredData, config.artifactThreshold);
            }

            // スクロールバーの最大値を更新
            const maxTime = filteredData.length / config.samplingRate;
            const maxScrollTime = Math.max(0, maxTime - config.displayWindow);
            document.getElementById('timeSlider').max = maxScrollTime;
            
            // データ再読み込み時はスクロールバーを先頭に戻す
            currentTime = 0;
            document.getElementById('timeSlider').value = 0;
            document.getElementById('timeDisplay').textContent = `0.0s / ${maxTime.toFixed(1)}s`;

            updateWaveformChart(); // これがFFTも自動更新するので、updateFFTChart()は不要
        }

        function exportToCSV(data, filename) {
            const csv = data.map(row => row.join(',')).join('\n');
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        // ==================== グラフ更新 ====================
        // ==================== UI更新関数 ====================
        function updateStatistics() {
            const startTime = currentTime;
            const endTime = currentTime + config.displayWindow;
            const displayData = filteredData.filter(d => d.time >= startTime && d.time <= endTime);
            
            const stats = calculateStatistics(displayData);
            if (!stats) return;
            
            let statsHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 12px;">
                    <div class="stat-card">
                        <div class="stat-label">平均値</div>
                        <div class="stat-value">${stats.mean} μV</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">標準偏差</div>
                        <div class="stat-value">${stats.std} μV</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">RMS</div>
                        <div class="stat-value">${stats.rms} μV</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">最大値</div>
                        <div class="stat-value">${stats.max} μV</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">最小値</div>
                        <div class="stat-value">${stats.min} μV</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">P-P値</div>
                        <div class="stat-value">${stats.peakToPeak} μV</div>
                    </div>
                </div>
            `;
            
            // ECG情報を追加
            if (isECG) {
                const hr = calculateHeartRate(rPeaks, config.samplingRate);
                if (hr) {
                    statsHTML += `
                        <div style="margin-top: 12px; padding: 12px; background: #e8f5e9; border-radius: 6px; border-left: 4px solid #4caf50;">
                            <div style="font-weight: 600; margin-bottom: 6px;">❤️ ECG検出</div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                                <div>心拍数: <strong>${hr.bpm} BPM</strong></div>
                                <div>HRV: <strong>${hr.hrv} ms</strong></div>
                            </div>
                        </div>
                    `;
                }
            }
            
            // アーチファクト情報
            if (config.detectArtifacts && artifacts.length > 0) {
                const displayArtifacts = artifacts.filter(a => a.time >= startTime && a.time <= endTime);
                if (displayArtifacts.length > 0) {
                    statsHTML += `
                        <div style="margin-top: 12px; padding: 12px; background: #ffebee; border-radius: 6px; border-left: 4px solid #f44336;">
                            <div style="font-weight: 600;">⚠️ アーチファクト: ${displayArtifacts.length}個検出</div>
                        </div>
                    `;
                }
            }
            
            document.getElementById('statisticsDisplay').innerHTML = statsHTML;
        }

        function addEventMarker(time, label = null) {
            if (!label) {
                label = prompt('イベント名を入力してください:', 'Event');
                if (!label) return;
            }
            
            eventMarkers.push({ time, label });
            eventMarkers.sort((a, b) => a.time - b.time);
            updateWaveformChart();
            updateMarkerList();
        }

        function updateMarkerList() {
            let html = '';
            eventMarkers.forEach((marker, idx) => {
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px; background: #f8f9fa; margin-bottom: 4px; border-radius: 4px;">
                        <span>${marker.time.toFixed(2)}s - ${marker.label}</span>
                        <button class="btn-small" onclick="removeMarker(${idx})" style="padding: 2px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">削除</button>
                    </div>
                `;
            });
            const container = document.getElementById('markerList');
            if (container) {
                container.innerHTML = html || '<div style="color: #999; font-size: 12px;">マーカーなし</div>';
            }
        }

        function removeMarker(index) {
            eventMarkers.splice(index, 1);
            updateWaveformChart();
            updateMarkerList();
        }

        function updateWaveformChart() {
            const startTime = currentTime;
            const endTime = currentTime + config.displayWindow;
            const displayData = filteredData.filter(d => d.time >= startTime && d.time <= endTime);

            // パフォーマンス最適化：データポイントが多い場合は間引く
            const downsampledData = downsampleData(displayData, 2000);

            // オートスケール時のY軸範囲を計算
            if (config.autoScale && downsampledData.length > 0) {
                const values = downsampledData.map(d => config.showRaw ? d.raw : d.filtered);
                const minVal = Math.min(...values);
                const maxVal = Math.max(...values);
                const margin = (maxVal - minVal) * 0.1; // 10%のマージン
                config.yMin = minVal - margin;
                config.yMax = maxVal + margin;
            }

            // データセットを構築
            const datasets = [{
                label: config.showRaw ? 'Raw (μV)' : 'フィルター後 (μV)',
                data: downsampledData.map(d => ({ x: d.time, y: config.showRaw ? d.raw : d.filtered })),
                borderColor: config.showRaw ? '#ff9800' : '#0066cc',
                backgroundColor: config.showRaw ? 'rgba(255, 152, 0, 0.1)' : 'rgba(0, 102, 204, 0.1)',
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0
            }];

            // R波とアーチファクトをデータセットとして追加

            // R波マーカーのデータセット
            if (isECG && rPeaks.length > 0) {
                const rPeakData = [];
                rPeaks.forEach((peakIdx) => {
                    const time = peakIdx / config.samplingRate;
                    if (time >= startTime && time <= endTime && peakIdx < filteredData.length) {
                        rPeakData.push({
                            x: time,
                            y: filteredData[peakIdx].filtered
                        });
                    }
                });
                
                if (rPeakData.length > 0) {
                    datasets.push({
                        label: 'R波',
                        data: rPeakData,
                        borderColor: 'rgb(255, 0, 0)',
                        backgroundColor: 'rgb(255, 0, 0)',
                        pointRadius: 6,
                        pointStyle: 'circle',
                        showLine: false,
                        pointHoverRadius: 8
                    });
                }
            }

            // イベントマーカーのデータセット
            if (eventMarkers.length > 0) {
                const markerData = [];
                eventMarkers.forEach((marker) => {
                    if (marker.time >= startTime && marker.time <= endTime) {
                        // マーカー位置のY値を取得（データがあれば）
                        const dataPoint = displayData.find(d => Math.abs(d.time - marker.time) < 0.01);
                        if (dataPoint) {
                            markerData.push({
                                x: marker.time,
                                y: dataPoint.filtered
                            });
                        }
                    }
                });
                
                if (markerData.length > 0) {
                    datasets.push({
                        label: 'イベント',
                        data: markerData,
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgb(255, 99, 132)',
                        pointRadius: 8,
                        pointStyle: 'triangle',
                        showLine: false,
                        pointHoverRadius: 10
                    });
                }
            }

            // アーチファクトの表示
            if (config.detectArtifacts && artifacts.length > 0) {
                const artifactData = [];
                artifacts.forEach((artifact) => {
                    if (artifact.time >= startTime && artifact.time <= endTime) {
                        artifactData.push({
                            x: artifact.time,
                            y: artifact.value
                        });
                    }
                });
                
                if (artifactData.length > 0) {
                    datasets.push({
                        label: 'アーチファクト',
                        data: artifactData,
                        borderColor: 'rgba(255, 0, 0, 0.6)',
                        backgroundColor: 'rgba(255, 0, 0, 0.3)',
                        pointRadius: 10,
                        pointStyle: 'crossRot',
                        showLine: false,
                        pointHoverRadius: 12
                    });
                }
            }

            if (!waveformChart) {
                const ctx = document.getElementById('waveformChart').getContext('2d');
                waveformChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        parsing: false, // パフォーマンス向上：パース処理をスキップ
                        normalized: true, // パフォーマンス向上
                        animation: false, // アニメーション無効化
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: '時間 (秒)' },
                                min: startTime,
                                max: endTime,
                                ticks: { 
                                    stepSize: 1,
                                    maxTicksLimit: 10, // ティック数を制限
                                    callback: function(value) {
                                        return Math.round(value);
                                    }
                                },
                                grid: {
                                    color: '#d0d0d0',
                                    lineWidth: 1.5
                                }
                            },
                            y: {
                                title: { display: true, text: '電圧 (μV)' },
                                min: config.yMin,
                                max: config.yMax,
                                grid: {
                                    color: '#d0d0d0'
                                }
                            }
                        },
                        plugins: {
                            legend: { display: true },
                            tooltip: { enabled: true },
                            zoom: {
                                zoom: {
                                    wheel: {
                                        enabled: false  // マウスホイールズーム無効化
                                    },
                                    pinch: {
                                        enabled: false  // ピンチズーム無効化
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            intersect: false
                        },
                        animation: false,
                        onClick: (event, elements, chart) => {
                            // グラフクリックでイベントマーカーを追加
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                            addEventMarker(dataX);
                        }
                    }
                });
                
                // マウスホイールでのズームを完全に無効化
                const waveformCanvas = document.getElementById('waveformChart');
                waveformCanvas.addEventListener('wheel', function(e) {
                    e.preventDefault();
                }, { passive: false });
            } else {
                waveformChart.data.datasets = datasets;
                waveformChart.options.scales.x.min = startTime;
                waveformChart.options.scales.x.max = endTime;
                waveformChart.options.scales.y.min = config.yMin;
                waveformChart.options.scales.y.max = config.yMax;
                waveformChart.update('none');
            }

            // 波形グラフ更新時にFFTと帯域データ、統計情報、ヒートマップも自動更新
            updateFFTChart();
            updateStatistics();
            updateHeatmap();
        }

        function updateFFTChart() {
            const startTime = currentTime;
            const endTime = currentTime + config.displayWindow;
            const displayData = filteredData.filter(d => d.time >= startTime && d.time <= endTime);

            // データ不足のチェック
            const minSamples = 512;  // FFT解析に必要な最小サンプル数
            const minSeconds = minSamples / config.samplingRate;  // 必要な最小秒数
            
            if (displayData.length < minSamples) {
                const warningMessage = `
                    <div style="padding: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; color: #856404; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                        <h3 style="margin-top: 0; color: #856404;">⚠️ FFT・帯域解析が表示できません</h3>
                        
                        <div style="background: white; padding: 12px; border-radius: 4px; margin: 12px 0;">
                            <p style="margin: 8px 0;"><strong>原因：</strong> 表示範囲のデータが不足しています</p>
                            <p style="margin: 8px 0;">
                                <strong>必要：</strong> ${minSamples}サンプル以上<br>
                                <strong>現在：</strong> ${displayData.length}サンプルのみ
                            </p>
                        </div>
                        
                        <div style="background: #fffaed; padding: 12px; border-radius: 4px; border-left: 4px solid #ff9800;">
                            <p style="margin: 8px 0; font-weight: bold; color: #e65100;">📝 対処方法：</p>
                            <p style="margin: 8px 0;">
                                <strong>「時系列波形グラフ」の下にある「表示時間幅」を増やしてください</strong>
                            </p>
                            <p style="margin: 8px 0; font-size: 16px;">
                                現在: <span style="background: #ffeb3b; padding: 2px 8px; border-radius: 3px;">${config.displayWindow}秒</span> 
                                → 
                                推奨: <span style="background: #4caf50; color: white; padding: 2px 8px; border-radius: 3px;">${Math.ceil(minSeconds)}秒以上</span>
                            </p>
                        </div>
                        
                        <p style="margin: 12px 0 0 0; font-size: 13px; color: #666;">
                            ※ 表示時間幅を増やすと、FFTスペクトル、帯域解析が正常に表示されます
                        </p>
                    </div>
                `;
                document.getElementById('dataWarningArea').innerHTML = warningMessage;
                document.getElementById('bandResults').innerHTML = '<div class="loading">データを再生して解析を開始してください</div>';
                
                // FFTグラフもクリア
                if (fftChart) {
                    fftChart.data.datasets[0].data = [];
                    fftChart.update('none');
                }
                return;
            }

            // データが十分な場合は警告をクリア
            document.getElementById('dataWarningArea').innerHTML = '';

            const values = displayData.map(d => d.filtered);
            const { freqs, power } = welchPowerSpectrum(values, config.samplingRate, 512, 0.5);

            // FFT表示データのフィルタリング
            // オートスケール時：3-40Hzでフィルタ
            // 手動設定時：指定範囲でフィルタ
            const filterMinFreq = config.fftAutoScale ? config.fftMinFreq : Math.max(0, config.fftXMin);
            const filterMaxFreq = config.fftAutoScale ? config.fftMaxFreq : config.fftXMax;
            
            const displayFFT = freqs.map((f, i) => ({
                frequency: f,
                power: config.fftYScale === 'db' ? 10 * Math.log10(power[i] + 1e-10) : power[i]
            })).filter(d => d.frequency >= filterMinFreq && d.frequency <= filterMaxFreq);

            if (!fftChart) {
                const ctx = document.getElementById('fftChart').getContext('2d');
                fftChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: displayFFT.map(d => d.frequency.toFixed(1)),
                        datasets: [{
                            label: config.fftYScale === 'db' ? 'PSD (dB/Hz)' : 'PSD (μV²/Hz)',
                            data: displayFFT.map(d => d.power),
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.2)',
                            borderWidth: 2,
                            fill: true,
                            pointRadius: 0,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: '周波数 (Hz)' },
                                ticks: { maxTicksLimit: 15 },
                                min: config.fftAutoScale ? config.fftMinFreq : config.fftXMin,
                                max: config.fftAutoScale ? config.fftMaxFreq : config.fftXMax
                            },
                            y: {
                                title: { display: true, text: config.fftYScale === 'db' ? 'PSD (dB/Hz)' : 'PSD (μV²/Hz)' },
                                min: config.fftAutoScale ? undefined : config.fftYMin,
                                max: config.fftAutoScale ? undefined : config.fftYMax
                            }
                        },
                        animation: false
                    }
                });
            } else {
                fftChart.data.labels = displayFFT.map(d => d.frequency.toFixed(1));
                fftChart.data.datasets[0].data = displayFFT.map(d => d.power);
                fftChart.data.datasets[0].label = config.fftYScale === 'db' ? 'PSD (dB/Hz)' : 'PSD (μV²/Hz)';
                fftChart.options.scales.x.min = config.fftAutoScale ? config.fftMinFreq : config.fftXMin;
                fftChart.options.scales.x.max = config.fftAutoScale ? config.fftMaxFreq : config.fftXMax;
                fftChart.options.scales.y.title.text = config.fftYScale === 'db' ? 'PSD (dB/Hz)' : 'PSD (μV²/Hz)';
                fftChart.options.scales.y.min = config.fftAutoScale ? undefined : config.fftYMin;
                fftChart.options.scales.y.max = config.fftAutoScale ? undefined : config.fftYMax;
                fftChart.update('none');
            }

            // 帯域パワー計算
            const bands = {
                delta: { min: 0.5, max: 4, name: 'デルタ (δ)', color: '#1f77b4', class: 'delta' },
                theta: { min: 4, max: 8, name: 'シータ (θ)', color: '#2ca02c', class: 'theta' },
                alpha: { min: 8, max: 13, name: 'アルファ (α)', color: '#bcbd22', class: 'alpha' },
                beta: { min: 13, max: 30, name: 'ベータ (β)', color: '#ff7f0e', class: 'beta' },
                gamma: { min: 30, max: 40, name: 'ガンマ (γ)', color: '#d62728', class: 'gamma' }
            };

            const results = {};
            let totalPower = 0;

            Object.keys(bands).forEach(key => {
                const band = bands[key];
                const { power: bandPower, peakFreq } = calculateBandPower(freqs, power, band.min, band.max);
                results[key] = { ...band, power: bandPower, peakFreq };
                totalPower += bandPower;
            });

            // 帯域データのテーブル表示
            let bandHTML = '';
            Object.keys(results).forEach(key => {
                const band = results[key];
                const ratio = (band.power / totalPower * 100).toFixed(1);
                bandHTML += `
                    <div class="band-card ${band.class}">
                        <div class="band-name">${band.name}</div>
                        <div class="band-value">${band.power.toFixed(2)} μV² <span style="color: #6c757d; font-size: 14px;">(${ratio}%)</span></div>
                        <div class="band-detail">ピーク: ${band.peakFreq.toFixed(1)} Hz</div>
                    </div>
                `;
            });
            document.getElementById('bandResults').innerHTML = bandHTML;

            // 帯域グラフを更新
            updateBandChart(results, totalPower);
            
            // エクスポート用にグローバル変数に保存
            window.currentFFTData = displayFFT;
            window.currentBandData = results;
        }

        function updateBandChart(results, totalPower) {
            const bandNames = Object.keys(results).map(key => results[key].name);
            const bandPowers = Object.keys(results).map(key => results[key].power);
            const bandRatios = Object.keys(results).map(key => (results[key].power / totalPower * 100).toFixed(1));
            const bandColors = Object.keys(results).map(key => results[key].color);

            if (!bandChart) {
                const ctx = document.getElementById('bandChart').getContext('2d');
                bandChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: bandNames,
                        datasets: [{
                            label: 'パワー (μV²)',
                            data: bandPowers,
                            backgroundColor: bandColors,
                            borderColor: bandColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'パワー (μV²)' },
                                min: config.bandAutoScale ? undefined : config.bandYMin,
                                max: config.bandAutoScale ? undefined : config.bandYMax
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        const ratio = bandRatios[context.dataIndex];
                                        return `${ratio}%`;
                                    }
                                }
                            },
                            legend: {
                                display: false
                            }
                        },
                        animation: false
                    }
                });
            } else {
                bandChart.data.labels = bandNames;
                bandChart.data.datasets[0].data = bandPowers;
                bandChart.data.datasets[0].backgroundColor = bandColors;
                bandChart.data.datasets[0].borderColor = bandColors;
                bandChart.options.scales.y.min = config.bandAutoScale ? undefined : config.bandYMin;
                bandChart.options.scales.y.max = config.bandAutoScale ? undefined : config.bandYMax;
                bandChart.update('none');
            }
        }


        // ==================== 再生制御 ====================
        function togglePlayback() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '■' : '▶';

            if (isPlaying) {
                // データ量に応じて更新間隔を調整（パフォーマンス最適化）
                const updateInterval = filteredData.length > 50000 ? 200 : 100; // 大量データの場合は200ms
                
                playbackInterval = setInterval(() => {
                    const maxTime = filteredData.length / config.samplingRate;
                    const maxScrollTime = Math.max(0, maxTime - config.displayWindow);
                    currentTime += 0.1 * config.playbackSpeed;
                    if (currentTime >= maxScrollTime) {
                        currentTime = maxScrollTime;
                        togglePlayback();
                    }
                    document.getElementById('timeSlider').value = currentTime;
                    document.getElementById('timeDisplay').textContent = 
                        `${currentTime.toFixed(1)}s / ${maxTime.toFixed(1)}s`;
                    updateWaveformChart(); // これがFFTも自動更新する
                }, updateInterval);
            } else {
                clearInterval(playbackInterval);
            }
        }

        function seekTime(delta) {
            const maxTime = filteredData.length / config.samplingRate;
            const maxScrollTime = Math.max(0, maxTime - config.displayWindow);
            currentTime = Math.max(0, Math.min(maxScrollTime, currentTime + delta));
            document.getElementById('timeSlider').value = currentTime;
            document.getElementById('timeDisplay').textContent = 
                `${currentTime.toFixed(1)}s / ${maxTime.toFixed(1)}s`;
            updateWaveformChart(); // これがFFTも自動更新する
        }

        // ==================== UI構築 ====================
        function buildUI() {
            // 左パネル
            document.getElementById('leftPanel').innerHTML = `
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 14px; font-weight: 600; color: #495057; margin-bottom: 12px;">ファイル読み込み</div>
                    <label class="file-upload" id="fileUploadArea">
                        <input type="file" accept=".csv" id="fileInput">
                        <div style="font-size: 15px; font-weight: 600; color: #495057; margin-bottom: 6px;">
                            クリックしてファイルを選択
                        </div>
                        <div style="font-size: 13px; color: #868e96;">
                            またはここにドラッグ&ドロップ
                        </div>
                        <div style="font-size: 11px; color: #adb5bd; margin-top: 16px;">
                            MAX30011 CSV形式 | ADC → mV → μV 変換
                        </div>
                    </label>
                    <div id="fileInfo"></div>
                </div>

                <div class="section">
                    <div class="section-title">基本設定</div>
                    <div class="input-group">
                        <label class="input-label">サンプリングレート (Hz)</label>
                        <input type="number" class="input-field" id="samplingRate" value="128" min="64" max="1000">
                        <div style="font-size: 11px; color: #6c757d; margin-top: 4px;">範囲: 64-1000 Hz</div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">プリセット</div>
                    <select class="input-field" id="presetSelect">
                        <option value="">カスタム</option>
                        <option value="Default">Default</option>
                        <option value="Sleep">Sleep (睡眠)</option>
                        <option value="Active">Active (活動)</option>
                        <option value="Meditation">Meditation (瞑想)</option>
                    </select>
                </div>

                <div class="section">
                    <div class="section-title">表示オプション</div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showRaw">
                        <label for="showRaw">Raw波形を表示</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableECG">
                        <label for="enableECG">心電検出</label>
                    </div>
                    <div class="input-group" style="margin-left: 24px;">
                        <label class="input-label">検出感度（閾値）</label>
                        <input type="range" class="input-field" id="ecgThreshold" min="30" max="80" value="60" step="5">
                        <div style="font-size: 11px; color: #6c757d; margin-top: 4px;">
                            <span id="ecgThresholdValue">60</span>% （低い=高感度、高い=低感度）
                        </div>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="detectArtifactsCheckbox" checked>
                        <label for="detectArtifactsCheckbox">アーチファクト検出</label>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">イベントマーカー</div>
                    <div style="font-size: 12px; color: #6c757d; margin-bottom: 8px;">グラフをクリックして追加</div>
                    <div id="markerList" style="max-height: 150px; overflow-y: auto;"></div>
                </div>

                <div class="section">
                    <div class="section-title">フィルター設定</div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="hpfEnabled" checked>
                        <label for="hpfEnabled">ハイパスフィルター</label>
                    </div>
                    <div class="filter-params" id="hpfParams">
                        <div>
                            <input type="number" class="input-field" id="hpfFreq" value="3.0" step="0.1" min="0.1">
                            <div style="font-size: 10px; color: #6c757d;">周波数 (Hz)</div>
                        </div>
                        <div>
                            <select class="select-field" id="hpfOrder">
                                <option value="1">1次</option>
                                <option value="2" selected>2次</option>
                            </select>
                            <div style="font-size: 10px; color: #6c757d;">次数</div>
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="lpfEnabled" checked>
                        <label for="lpfEnabled">ローパスフィルター</label>
                    </div>
                    <div class="filter-params" id="lpfParams">
                        <div>
                            <input type="number" class="input-field" id="lpfFreq" value="40.0" step="0.1" min="0.1">
                            <div style="font-size: 10px; color: #6c757d;">周波数 (Hz)</div>
                        </div>
                        <div>
                            <select class="select-field" id="lpfOrder">
                                <option value="1">1次</option>
                                <option value="2" selected>2次</option>
                            </select>
                            <div style="font-size: 10px; color: #6c757d;">次数</div>
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="notch50Enabled" checked>
                        <label for="notch50Enabled">ノッチ 50Hz</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="notch60Enabled" checked>
                        <label for="notch60Enabled">ノッチ 60Hz</label>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">FFT表示設定</div>
                    <div class="input-group">
                        <label class="input-label">表示範囲 (Hz)</label>
                        <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                            <input type="number" class="input-field" id="fftMinFreq" value="3" step="0.5" min="0.5">
                            <span>〜</span>
                            <input type="number" class="input-field" id="fftMaxFreq" value="40" step="0.5" max="64">
                        </div>
                        <div style="font-size: 11px; color: #6c757d; margin-top: 4px;">範囲: 0.5-64 Hz</div>
                    </div>
                    <div class="input-group">
                        <label class="input-label">Y軸表示</label>
                        <div class="radio-group">
                            <div class="radio-item">
                                <input type="radio" id="powerScale" name="fftYScale" checked>
                                <label for="powerScale">PSD (μV²/Hz)</label>
                            </div>
                            <div class="radio-item">
                                <input type="radio" id="dbScale" name="fftYScale">
                                <label for="dbScale">dB</label>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">エクスポート</div>
                    <div class="export-buttons">
                        <button class="btn btn-primary btn-small" onclick="exportRawData()">📥 Raw CSV</button>
                        <button class="btn btn-primary btn-small" onclick="exportFilteredData()">📥 Filtered CSV</button>
                        <button class="btn btn-primary btn-small" onclick="exportFFTDetail()">📥 FFT Detail</button>
                        <button class="btn btn-primary btn-small" onclick="exportFFTBands()">📥 FFT Bands</button>
                        <button class="btn btn-primary btn-small" onclick="generatePDFReport()" style="background: #e74c3c;">📄 PDF Report</button>
                    </div>
                </div>
            `;

            // 右パネル
            document.getElementById('rightPanel').innerHTML = `
                <div class="playback-controls">
                    <button class="btn btn-secondary btn-small" onclick="seekTime(-5)">◀◀</button>
                    <button class="btn btn-primary btn-small" id="playBtn" onclick="togglePlayback()">▶</button>
                    <button class="btn btn-secondary btn-small" onclick="seekTime(5)">▶▶</button>
                    <select class="select-field" id="playbackSpeed" style="width: auto;">
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="1" selected>1x</option>
                        <option value="2">2x</option>
                        <option value="4">4x</option>
                    </select>
                    <div class="slider-container">
                        <input type="range" class="slider" id="timeSlider" min="0" max="100" step="0.1" value="0">
                        <div class="time-display" id="timeDisplay">0.0s / 0.0s</div>
                    </div>
                </div>
                
                <div class="graph-container">
                    <div class="graph-title">
                        <span>時系列波形グラフ</span>
                        <div class="control-item">
                            <input type="checkbox" id="autoScale" checked>
                            <label for="autoScale">オートスケール</label>
                        </div>
                    </div>
                    <div class="graph-controls" id="manualScaleControls" style="display: none;">
                        <div class="control-item">
                            <span>Y軸最小:</span>
                            <input type="number" id="yMin" value="-200">
                            <span>μV</span>
                        </div>
                        <div class="control-item">
                            <span>Y軸最大:</span>
                            <input type="number" id="yMax" value="200">
                            <span>μV</span>
                        </div>
                    </div>
                    <div style="height: 300px;">
                        <canvas id="waveformChart"></canvas>
                    </div>
                    <div class="graph-controls">
                        <div class="control-item">
                            <span>表示時間幅:</span>
                            <input type="number" id="displayWindow" value="5" min="1" max="60">
                            <span>秒</span>
                        </div>
                    </div>
                </div>

                <!-- データ不足警告表示エリア -->
                <div id="dataWarningArea" style="margin-bottom: 16px;"></div>

                <div class="graph-container">
                    <div class="graph-title">
                        <span>FFTスペクトルグラフ</span>
                        <div class="control-item">
                            <input type="checkbox" id="fftAutoScale" checked>
                            <label for="fftAutoScale">オートスケール</label>
                        </div>
                    </div>
                    <div class="graph-controls" id="fftManualScaleControls" style="display: none;">
                        <div class="control-item">
                            <span>X軸最小:</span>
                            <input type="number" id="fftXMin" value="0" step="5">
                            <span>Hz</span>
                        </div>
                        <div class="control-item">
                            <span>X軸最大:</span>
                            <input type="number" id="fftXMax" value="50" step="5">
                            <span>Hz</span>
                        </div>
                        <div class="control-item">
                            <span>Y軸最小:</span>
                            <input type="number" id="fftYMin" value="0" step="10">
                            <span>μV²/Hz</span>
                        </div>
                        <div class="control-item">
                            <span>Y軸最大:</span>
                            <input type="number" id="fftYMax" value="100" step="10">
                            <span>μV²/Hz</span>
                        </div>
                    </div>
                    <div style="height: 250px;">
                        <canvas id="fftChart"></canvas>
                    </div>
                </div>

                <div class="graph-container">
                    <div class="graph-title">
                        <span>帯域解析結果</span>
                        <div class="control-item">
                            <input type="checkbox" id="bandAutoScale" checked>
                            <label for="bandAutoScale">オートスケール</label>
                        </div>
                    </div>
                    <div class="graph-controls" id="bandManualScaleControls" style="display: none;">
                        <div class="control-item">
                            <span>Y軸最小:</span>
                            <input type="number" id="bandYMin" value="0" step="50">
                            <span>μV²</span>
                        </div>
                        <div class="control-item">
                            <span>Y軸最大:</span>
                            <input type="number" id="bandYMax" value="500" step="50">
                            <span>μV²</span>
                        </div>
                    </div>
                    <div style="height: 200px; margin-bottom: 16px;">
                        <canvas id="bandChart"></canvas>
                    </div>
                    <div class="band-results" id="bandResults">
                        <div class="loading">データを再生して解析を開始してください</div>
                    </div>
                </div>

                <div class="graph-container">
                    <div class="graph-title">スペクトログラム（時間-周波数解析）</div>
                    <div style="position: relative;">
                        <canvas id="heatmapCanvas" style="width: 100%; height: 350px; border: 1px solid #ddd; border-radius: 4px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.05);"></canvas>
                        <div id="heatmapColorbar" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); width: 25px; height: 200px; border: 1px solid #333; border-radius: 3px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="graph-container">
                    <div class="graph-title">統計情報</div>
                    <div id="statisticsDisplay">
                        <div class="loading">データを読み込んでください</div>
                    </div>
                </div>
            `;

            // イベントリスナー設定
            setupEventListeners();
        }

        function setupEventListeners() {
            // ファイル読み込み（通常）
            document.getElementById('fileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    loadFile(file);
                }
            });

            // ドラッグ&ドロップ
            const uploadArea = document.getElementById('fileUploadArea');
            
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.add('drag-over');
            });

            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('drag-over');
            });

            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.endsWith('.csv')) {
                        loadFile(file);
                    } else {
                        alert('CSVファイルを選択してください');
                    }
                }
            });

            // ファイル読み込み共通処理
            function loadFile(file) {
                const startTime = performance.now(); // パフォーマンス計測開始
                
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const parseStart = performance.now();
                    rawData = parseMAX30011CSV(evt.target.result);
                    const parseTime = performance.now() - parseStart;
                    
                    currentTime = 0;
                    const maxTime = rawData.length / config.samplingRate;
                    
                    document.getElementById('fileInfo').innerHTML = `
                        <div class="file-info">
                            ✓ ${file.name}<br/>
                            ${rawData.length.toLocaleString()} サンプル (${maxTime.toFixed(1)}秒)<br/>
                            <small style="color: #6c757d;">読み込み: ${parseTime.toFixed(0)}ms</small>
                        </div>
                    `;
                    
                    const maxScrollTime = Math.max(0, maxTime - config.displayWindow);
                    document.getElementById('timeSlider').max = maxScrollTime;
                    document.getElementById('timeDisplay').textContent = `0.0s / ${maxTime.toFixed(1)}s`;
                    
                    const filterStart = performance.now();
                    applyFilters();
                    const filterTime = performance.now() - filterStart;
                    
                    const totalTime = performance.now() - startTime;
                    
                    // パフォーマンス情報をコンソールに表示
                    console.log('=== パフォーマンス情報 ===');
                    console.log(`ファイル名: ${file.name}`);
                    console.log(`サンプル数: ${rawData.length.toLocaleString()}`);
                    console.log(`データ長: ${maxTime.toFixed(1)}秒`);
                    console.log(`CSV解析時間: ${parseTime.toFixed(0)}ms`);
                    console.log(`フィルター処理時間: ${filterTime.toFixed(0)}ms`);
                    console.log(`合計読み込み時間: ${totalTime.toFixed(0)}ms`);
                    console.log('=======================');
                };
                reader.readAsText(file);
            }

            // 設定変更
            document.getElementById('samplingRate').addEventListener('change', function() {
                config.samplingRate = Number(this.value);
                applyFilters();
            });

            // フィルター設定
            document.getElementById('hpfEnabled').addEventListener('change', function() {
                config.hpfEnabled = this.checked;
                applyFilters();
            });
            document.getElementById('hpfFreq').addEventListener('change', function() {
                config.hpfFreq = Number(this.value);
                applyFilters();
            });
            document.getElementById('hpfOrder').addEventListener('change', function() {
                config.hpfOrder = Number(this.value);
                applyFilters();
            });
            
            document.getElementById('lpfEnabled').addEventListener('change', function() {
                config.lpfEnabled = this.checked;
                applyFilters();
            });
            document.getElementById('lpfFreq').addEventListener('change', function() {
                config.lpfFreq = Number(this.value);
                applyFilters();
            });
            document.getElementById('lpfOrder').addEventListener('change', function() {
                config.lpfOrder = Number(this.value);
                applyFilters();
            });

            document.getElementById('notch50Enabled').addEventListener('change', function() {
                config.notch50Enabled = this.checked;
                applyFilters();
            });
            document.getElementById('notch60Enabled').addEventListener('change', function() {
                config.notch60Enabled = this.checked;
                applyFilters();
            });

            // オートスケール
            document.getElementById('autoScale').addEventListener('change', function() {
                config.autoScale = this.checked;
                document.getElementById('manualScaleControls').style.display = this.checked ? 'none' : 'flex';
                if (this.checked) {
                    applyFilters();
                } else {
                    // オートスケールOFF時、現在の値を入力欄に設定
                    document.getElementById('yMin').value = config.yMin.toFixed(1);
                    document.getElementById('yMax').value = config.yMax.toFixed(1);
                }
            });
            document.getElementById('yMin').addEventListener('change', function() {
                config.yMin = Number(this.value);
                updateWaveformChart();
            });
            document.getElementById('yMax').addEventListener('change', function() {
                config.yMax = Number(this.value);
                updateWaveformChart();
            });

            // FFTグラフのオートスケール
            document.getElementById('fftAutoScale').addEventListener('change', function() {
                config.fftAutoScale = this.checked;
                document.getElementById('fftManualScaleControls').style.display = this.checked ? 'none' : 'flex';
                if (!this.checked) {
                    // オートスケールOFF時、現在の実際の表示範囲を入力欄に設定
                    if (fftChart && fftChart.scales) {
                        // Chart.jsの実際のスケール値を取得
                        const yMin = fftChart.scales.y.min || 0;
                        const yMax = fftChart.scales.y.max || 100;
                        const xMin = fftChart.scales.x.min || config.fftMinFreq;
                        const xMax = fftChart.scales.x.max || config.fftMaxFreq;
                        
                        document.getElementById('fftYMin').value = yMin.toFixed(1);
                        document.getElementById('fftYMax').value = yMax.toFixed(1);
                        document.getElementById('fftXMin').value = xMin.toFixed(1);
                        document.getElementById('fftXMax').value = xMax.toFixed(1);
                        
                        config.fftYMin = yMin;
                        config.fftYMax = yMax;
                        config.fftXMin = xMin;
                        config.fftXMax = xMax;
                    }
                }
                updateFFTChart();
            });
            document.getElementById('fftYMin').addEventListener('change', function() {
                config.fftYMin = Number(this.value);
                updateFFTChart();
            });
            document.getElementById('fftYMax').addEventListener('change', function() {
                config.fftYMax = Number(this.value);
                updateFFTChart();
            });
            document.getElementById('fftXMin').addEventListener('change', function() {
                config.fftXMin = Number(this.value);
                updateFFTChart();
            });
            document.getElementById('fftXMax').addEventListener('change', function() {
                config.fftXMax = Number(this.value);
                updateFFTChart();
            });

            // 帯域グラフのオートスケール
            document.getElementById('bandAutoScale').addEventListener('change', function() {
                config.bandAutoScale = this.checked;
                document.getElementById('bandManualScaleControls').style.display = this.checked ? 'none' : 'flex';
                if (!this.checked && bandChart && bandChart.scales) {
                    // オートスケールOFF時、現在の実際の表示範囲を入力欄に設定
                    const yMin = bandChart.scales.y.min || 0;
                    const yMax = bandChart.scales.y.max || 500;
                    
                    document.getElementById('bandYMin').value = yMin.toFixed(1);
                    document.getElementById('bandYMax').value = yMax.toFixed(1);
                    
                    config.bandYMin = yMin;
                    config.bandYMax = yMax;
                }
                updateFFTChart(); // 帯域グラフはupdateFFTChart内で更新される
            });
            document.getElementById('bandYMin').addEventListener('change', function() {
                config.bandYMin = Number(this.value);
                updateFFTChart();
            });
            document.getElementById('bandYMax').addEventListener('change', function() {
                config.bandYMax = Number(this.value);
                updateFFTChart();
            });

            // FFT設定
            document.getElementById('fftMinFreq').addEventListener('change', function() {
                config.fftMinFreq = Number(this.value);
                updateFFTChart(); // FFT設定変更時のみ直接呼び出し
            });
            document.getElementById('fftMaxFreq').addEventListener('change', function() {
                config.fftMaxFreq = Number(this.value);
                updateFFTChart(); // FFT設定変更時のみ直接呼び出し
            });
            document.getElementById('powerScale').addEventListener('change', function() {
                config.fftYScale = 'power';
                updateFFTChart(); // FFT設定変更時のみ直接呼び出し
            });
            document.getElementById('dbScale').addEventListener('change', function() {
                config.fftYScale = 'db';
                updateFFTChart(); // FFT設定変更時のみ直接呼び出し
            });

            // 再生設定
            document.getElementById('playbackSpeed').addEventListener('change', function() {
                config.playbackSpeed = Number(this.value);
            });
            document.getElementById('timeSlider').addEventListener('input', function() {
                currentTime = Number(this.value);
                const maxTime = filteredData.length / config.samplingRate;
                document.getElementById('timeDisplay').textContent = 
                    `${currentTime.toFixed(1)}s / ${maxTime.toFixed(1)}s`;
                updateWaveformChart(); // これがFFTも自動更新する
            });
            document.getElementById('displayWindow').addEventListener('change', function() {
                config.displayWindow = Number(this.value);
                // 表示時間幅変更時にスクロールバーの最大値を更新
                const maxTime = filteredData.length / config.samplingRate;
                const maxScrollTime = Math.max(0, maxTime - config.displayWindow);
                document.getElementById('timeSlider').max = maxScrollTime;
                // currentTimeが新しい最大値を超えていたら調整
                if (currentTime > maxScrollTime) {
                    currentTime = maxScrollTime;
                    document.getElementById('timeSlider').value = currentTime;
                    document.getElementById('timeDisplay').textContent = 
                        `${currentTime.toFixed(1)}s / ${maxTime.toFixed(1)}s`;
                }
                updateWaveformChart(); // これがFFTも自動更新する
            });

            // プリセット選択
            document.getElementById('presetSelect').addEventListener('change', function() {
                const preset = presets[this.value];
                if (preset) {
                    config.hpfFreq = preset.hpfFreq;
                    config.lpfFreq = preset.lpfFreq;
                    config.hpfOrder = preset.hpfOrder;
                    config.lpfOrder = preset.lpfOrder;
                    config.notch50Enabled = preset.notch50Enabled;
                    config.notch60Enabled = preset.notch60Enabled;
                    config.fftMinFreq = preset.fftMinFreq;
                    config.fftMaxFreq = preset.fftMaxFreq;
                    
                    // UIを更新
                    document.getElementById('hpfFreq').value = preset.hpfFreq;
                    document.getElementById('lpfFreq').value = preset.lpfFreq;
                    document.getElementById('hpfOrder').value = preset.hpfOrder;
                    document.getElementById('lpfOrder').value = preset.lpfOrder;
                    document.getElementById('notch50Enabled').checked = preset.notch50Enabled;
                    document.getElementById('notch60Enabled').checked = preset.notch60Enabled;
                    document.getElementById('fftMinFreq').value = preset.fftMinFreq;
                    document.getElementById('fftMaxFreq').value = preset.fftMaxFreq;
                    
                    applyFilters();
                }
            });

            // Raw波形表示切替
            document.getElementById('showRaw').addEventListener('change', function() {
                config.showRaw = this.checked;
                updateWaveformChart();
            });

            // 心電検出切替
            document.getElementById('enableECG').addEventListener('change', function() {
                config.enableECG = this.checked;
                applyFilters();
            });

            // ECG閾値調整
            document.getElementById('ecgThreshold').addEventListener('input', function() {
                config.ecgThreshold = Number(this.value);
                document.getElementById('ecgThresholdValue').textContent = this.value;
                if (config.enableECG) {
                    applyFilters();
                }
            });

            // アーチファクト検出切替
            document.getElementById('detectArtifactsCheckbox').addEventListener('change', function() {
                config.detectArtifacts = this.checked;
                applyFilters();
            });

        }

        // エクスポート関数
        function exportRawData() {
            const data = [
                ['timestamp', 'time(s)', 'raw_ADC', 'raw(μV)'],
                ...rawData.map((d, i) => [
                    d.timestamp, 
                    (i / config.samplingRate).toFixed(3), 
                    d.rawADC,
                    d.value.toFixed(6)
                ])
            ];
            exportToCSV(data, 'raw_data.csv');
        }

        function exportFilteredData() {
            const data = [
                ['timestamp', 'time(s)', 'filtered(μV)'],
                ...filteredData.map(d => [d.timestamp, d.time.toFixed(3), d.filtered.toFixed(6)])
            ];
            exportToCSV(data, 'filtered_data.csv');
        }

        function exportFFTDetail() {
            if (!window.currentFFTData) return;
            const data = [
                ['frequency(Hz)', config.fftYScale === 'db' ? 'PSD(dB/Hz)' : 'PSD(μV²/Hz)'],
                ...window.currentFFTData.map(d => [d.frequency.toFixed(2), d.power.toFixed(6)])
            ];
            exportToCSV(data, 'fft_detailed.csv');
        }

        function exportFFTBands() {
            if (!window.currentBandData) return;
            const results = window.currentBandData;
            const bands = Object.keys(results);
            let totalPower = 0;
            bands.forEach(key => totalPower += results[key].power);
            
            const data = [
                ['band', 'power(μV²)', 'ratio(%)', 'peak_freq(Hz)'],
                ...bands.map(key => {
                    const band = results[key];
                    const ratio = (band.power / totalPower * 100).toFixed(1);
                    return [band.name, band.power.toFixed(6), ratio, band.peakFreq.toFixed(2)];
                })
            ];
            exportToCSV(data, 'fft_bands.csv');
        }

        // ==================== PDF生成機能 ====================
        async function generatePDFReport() {
            if (typeof jsPDF === 'undefined') {
                alert('PDFライブラリの読み込みに失敗しました');
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            let yPos = 20;

            // タイトル
            doc.setFontSize(20);
            doc.text('MAX30011 Analysis Report', 105, yPos, { align: 'center' });
            yPos += 15;

            // ファイル情報
            doc.setFontSize(12);
            doc.text(`Date: ${new Date().toLocaleString()}`, 20, yPos);
            yPos += 8;
            doc.text(`Samples: ${filteredData.length}`, 20, yPos);
            yPos += 8;
            doc.text(`Duration: ${(filteredData.length / config.samplingRate).toFixed(1)}s`, 20, yPos);
            yPos += 15;

            // 統計情報
            const startTime = currentTime;
            const endTime = currentTime + config.displayWindow;
            const displayData = filteredData.filter(d => d.time >= startTime && d.time <= endTime);
            const stats = calculateStatistics(displayData);

            if (stats) {
                doc.setFontSize(14);
                doc.text('Statistics', 20, yPos);
                yPos += 8;
                doc.setFontSize(10);
                doc.text(`Mean: ${stats.mean} μV`, 20, yPos);
                doc.text(`Std: ${stats.std} μV`, 70, yPos);
                doc.text(`RMS: ${stats.rms} μV`, 120, yPos);
                yPos += 6;
                doc.text(`Max: ${stats.max} μV`, 20, yPos);
                doc.text(`Min: ${stats.min} μV`, 70, yPos);
                doc.text(`P-P: ${stats.peakToPeak} μV`, 120, yPos);
                yPos += 12;
            }

            // ECG情報
            if (isECG) {
                const hr = calculateHeartRate(rPeaks, config.samplingRate);
                if (hr) {
                    doc.setFontSize(14);
                    doc.text('ECG Analysis', 20, yPos);
                    yPos += 8;
                    doc.setFontSize(10);
                    doc.text(`Heart Rate: ${hr.bpm} BPM`, 20, yPos);
                    doc.text(`HRV: ${hr.hrv} ms`, 70, yPos);
                    yPos += 12;
                }
            }

            // 帯域解析結果
            if (window.currentBandData) {
                doc.setFontSize(14);
                doc.text('Band Analysis', 20, yPos);
                yPos += 8;
                doc.setFontSize(10);
                
                const results = window.currentBandData;
                let totalPower = 0;
                Object.keys(results).forEach(key => {
                    totalPower += results[key].power;
                });

                Object.keys(results).forEach(key => {
                    const band = results[key];
                    const ratio = (band.power / totalPower * 100).toFixed(1);
                    doc.text(`${band.name}: ${band.power.toFixed(2)} μV² (${ratio}%)`, 20, yPos);
                    yPos += 6;
                });
                yPos += 10;
            }

            // グラフ画像を追加
            try {
                const waveformCanvas = document.getElementById('waveformChart');
                const fftCanvas = document.getElementById('fftChart');
                
                if (waveformCanvas) {
                    const imgData = waveformCanvas.toDataURL('image/png');
                    doc.addPage();
                    doc.setFontSize(14);
                    doc.text('Waveform', 20, 20);
                    doc.addImage(imgData, 'PNG', 15, 30, 180, 100);
                }

                if (fftCanvas) {
                    const imgData = fftCanvas.toDataURL('image/png');
                    doc.setFontSize(14);
                    doc.text('FFT Spectrum', 20, 145);
                    doc.addImage(imgData, 'PNG', 15, 155, 180, 100);
                }
            } catch (error) {
                console.error('グラフ画像の追加に失敗:', error);
            }

            // PDFを保存
            doc.save('max30011_report.pdf');
        }

        // 初期化
        window.onload = function() {
            buildUI();
            updateMarkerList();
            updateComparisonList();
        };
    </script>
</body>
</html>
